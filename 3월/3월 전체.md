# 1.MAR.2023
3월 시작!!! 학원에서 한것 복습


# 2.MAR.2023
학원 수업

# 3.MAR.2023
학원 파일에 많이 넣었다.. static 키워드 그리고 객체지향에 대해 깊게 알게됨

# 4.MAR.2023
학원에서 내준 성적내기 문제

# 5.MAR.2023
성적 출력 프로그램 코드
```java
package GradeArray;

import java.util.Arrays;
import java.util.Scanner;

class StudentN {
	
	public StudentN() {}
	
	String name;
	
	StudentN(String name) {
		this.name = name;
	}
	
}

class StudentG {
	
	public StudentG() {}
	
	int kor;
	int eng;
	int mat;
	
	StudentG(int kor, int eng, int mat) {
		this.kor = kor;
		this.eng = eng;
		this.mat = mat;
	}
	
	
}

class CaculN {
	
	// 학생 이름을 배열에 등록
	int size;
	
	StudentN[] st;
	
	CaculN(int size) {
		StudentN[] st = new StudentN[size];
	}
	
	void register(StudentN[] stArr) {
		
		st = stArr;
		
	}
	
	StudentN[] getStudentN() {
		return st;
	}
	
	//////////////////////////////////////////////////////
}

class CaculG {
	
	int size;
	int sizeG;

	StudentG[][] gr;

	CaculG(int sizeG) {
		StudentG[][] gr = new StudentG[size][sizeG];
	}
	
	void register(StudentG[][] stArr) {
		
		gr = stArr;
	}
	
	StudentG[][] getStudentG() {
		return gr;
	}

}




public class Student {
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		System.out.println("학생 수를 입력해주세요.");
		int size = sc.nextInt();
		
		System.out.println("과목 수를 입력해 주세요.");
		int sizeG = sc.nextInt();
		
		StudentN[] student = new StudentN[size];
		
		for(int i=0;i<size;i++) {
			System.out.println((i+1) + "번 학생을 등록");
			String n = sc.next();
			
			StudentN s = new StudentN(n);
			
			student[i] = s;
			
		}
		// 학생 이름을 배열에 등록
		CaculN r1 = new CaculN(size);
		r1.register(student);
		StudentN[] st = r1.getStudentN();
		
		
		////////////////////////////////////////////////////////////
		
		StudentG[][] grade = new StudentG[size][sizeG];
		
		for(int j=0;j<size;j++) {
			System.out.println((j+1) + "번 학생 국어 점수 입력");
			int k = sc.nextInt();
			System.out.println((j+1) + "번 학생 영어 점수 입력");
			int e = sc.nextInt();
			System.out.println((j+1) + "번 학생 수학 점수 입력");
			int m = sc.nextInt();
			
			StudentG ss = new StudentG(k, e, m);
			
			for(int jj=0;jj<sizeG;jj++) {
				grade[j][jj] = k;
				
				
			}
			
			
		}

		
	}

}

```

# 5.MAR.2023
학원 문제 

### 이걸 이제 객체지향 코드로 구현하면 됨 지금 한것은 절차지향
~~~java
import java.util.Arrays;
import java.util.Scanner;




class StudentAdd {
    int studentAdd(int a, int b, int c) {
        int sum = a+b+c;
        return sum;
    }
}

class SubjectAdd {

    int SubjectAdd(int a, int b, int c) {
        int sum = a+b+c;
        return sum;
    }
}

class StudentAverage {

    int StudentAverage(int a) {
        int sum = a/3;
        return  sum;
    }
}

class SubjectAverage {
    int SubjectAverage(int a, int b) {
        int sum = a / b;
        return sum;
    }
}
public class Main {
    public static void main(String[] args) {


        // 학생 이름 입력
        Scanner sc = new Scanner(System.in);
        System.out.println("학생 수를 입력해주세요");
        int num = sc.nextInt();
        String[] students = new String[num];

        for(int i=0;i<num;i++) {
            System.out.println((i+1) + "번 학생의 이름을 입력");

            students[i] = sc.next();
        }

        System.out.println(students[0]);


        //

        System.out.println("***성적을 입력하겠습니다.***");

        int[][] scores = new int[num][3];

        for(int j=0;j<num;j++) {
            System.out.println(students[j]+ "의 국어, 영어, 수학 점수를 입력해주세요");
            for(int k=0;k<3;k++) {
                scores[j][k] = sc.nextInt();

            }
        }
        // 전체 학생 국어 합
        int num1 = scores[0][0] + scores[1][0] + scores[2][0];

        // 전체 학생 영어 합
        int num2 = scores[0][1] + scores[1][1] + scores[2][1];

        // 전체 학생 수학 합
        int num3 = scores[0][2] + scores[1][2] + scores[2][2];

        // 전체 학생 국어 평균
        int num1a = num1/num;

        // 전체 학생 영어 평균
        int num2a = num2/num;

        // 전체 학생 수학 평균
        int num3a = num3/num;


        // 총합 합
        int allNum = num1 + num2 + num3;

        // 총합 합 평균
        int allNumave = allNum / 3;

        // 평균 합
        int all = num1a + num2a + num3a;

        // 평균 평균
        int allAve = all/3;

        int a = scores[0][0] + scores[0][1] + scores[0][2];
        int b = scores[1][0] + scores[1][1] + scores[1][2];
        int c = scores[2][0] + scores[2][1] + scores[2][2];


        int a1 = (scores[0][0] + scores[0][1] + scores[0][2]) / 3;
        int b1 = (scores[1][0] + scores[1][1] + scores[1][2]) / 3;
        int c1 = (scores[2][0] + scores[2][1] + scores[2][2]) / 3;



        System.out.println("   성적표(tit)");
        System.out.println("   이름  국어  영어  수학  총점  평균");
        System.out.println("===========================");
        System.out.println("   "+students[0] + " " + scores[0][0] +
                " " + scores[0][1] + " " + scores[0][2] + " " +a + " " + a1);
        System.out.println("   "+students[1] + " " + scores[1][0] +
                " " + scores[1][1] + " " + scores[1][2] + " " +b + " " + b1);
        System.out.println("   "+students[2] + " " + scores[2][0] +
                " " + scores[2][1] + " " + scores[2][2] + " " +c + " " + c1);
        System.out.println("===========================");

        System.out.println("합계   " + num1 + " " + num2 + " " + num3 + " " + allNum + " " + allNumave);
        System.out.println("평균   " + num1a + " " + num2a + " " + num3a + " " + all + " " +allAve);


    }
}

// 이걸 객체지향 코드로 구현하면 되겠다!!!
~~~

# 6.MAR.2023

### 부모클래스에서 private 걸려있는것은 자식클래스에서 사용할 수 없다.

### 같은 파일에 클래스가 여러개일때는 public은 1개여야함

# 7.MAR.2023

- 자바에서 다중상속은 기본적으로 불가능하다.
- 그렇지만 인터페이스를 통해 가능하다

다중상속을 받을때 메서드명이 같은경우 처리하는 방법
```java
interface A {
    void foo();
}

interface B {
    void foo();
}

class MyClass implements A, B {
    public void foo() {
        A.super.foo();
        B.super.foo();
    }
}

```

### 오버라이딩 시 @Override 어노테이션을 사용하는 이유
- 코드의 가독성 향상
- 컴파일러 오류 검출 ( 오탈자 등 )

## 인터페이스 사용 이유
- 다형성 구형 : 여러 개의 클래스가 같은 인터페이스를 구현하면, 이 인터페이스를 구현한 클래스들을 하나의 타입으로 취급 가능, 유연성, 재사용성 향상
- 계약규약 제공 : 인터페이스에서 정의한 모든 메서드를 반드시 구현해야 한다, 이를 통해 코드의 일관성과 안정성이 유지, 오류 줄임
- 코드 분리 : 인터페이스는 구현하지 않고 메서드명만을 정의할 수 있기에 클래스와 인터페이스를 분리하여 코드의 응집성을 높임
- 유지보수성 향상 : 클래스의 변경 없이도 새로운 기능을 추가할 


// 요일별로 쓰는게 아니라... 그때그때마다 필요한 키워드를 readme에 넣어서 사용하도록 만드는게 더 중요할거 같다

### static 인지 private인지 잘 알아두기!!!


# 8.MAR.2023

#### 익명클래스
new class만 있는것이 익명클래스
```java
public class Main {
  public static void main(String[] args) {
    // 익명 클래스로 Runnable 구현체 생성
    Runnable runnable = new Runnable() {
      @Override
      public void run() {
        System.out.println("Hello, world!");
      }
    };
    
    // 생성한 구현체 실행
    runnable.run();
  }
}
```

#### 람다함수
- 함수형 프로그래밍 기능 중 하나
- 람다 함수는 메서드로 전달할 수 있는 익명 함수를 의미

```java
(parameter) -> expression
```

- parameter는 함수의 매개변수를 나타내고 ->는 goes to를 의미함, expression은 함수가 수행하는 동작을 나타냄
- 이를 통해 함수의 반환값을 정의할 수 있다
- 위에 코드에서 람다함수 () -> { sout("Hello world!") } 는 매개변수가 없고, { sout("Hello world!") } 를 수행하여
- "Hello, world!"를 출력함 이후에는 람다 함수를 변수에 할당하고, 해당 변수의 run() 메서드를 호출하여 실행할 수 있음
- 람다 함수는 간결하게 코드를 작성할 수 있고, 함수형 인터페이스를 구현하는 클래스를 직접하지 않아도 됨
- 스트림(stream) API와 함꼐 사용하면 함수형 프로그래밍을 더욱 쉽고 간편하게 구현할 수 있음

#### 함수형 인터페이스
- 하나의 추상 메서드만을 갖는 인터페이스를 의미함
- 람다 함수, 메서드 참조를 사용하여 함수형 프로그래밍을 지원하는데 중요한 역할
- @FunctionalInterface 어노테이션을 이용하여 선언할 수 있음
```java
@FunctionalInterface
public interface MyFunctionalInterface {
  public void myMethod();
}
```

#### Consumer T , Function T, R 제네릭?
- 첫번째는 하나의 인자를 받아서 처리하는 함수
- 두번째는 하나의 인자를 받아서 반환값을 생성하는 함수를 나타냄
- 이러한 함수형 인터페이스를 사용하면, 반복적인 코드를 줄이고 가독성이 높아짐
